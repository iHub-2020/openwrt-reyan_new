#!/bin/sh /etc/rc.common
# Copyright (C) 2024 iHub-2020
#
# OpenWrt init script for udp2raw tunnels
# Supports multiple tunnel instances with proper error handling
# and iptables rule management
#
# Version: 1.0.1
# Last Updated: 2026-01-09
#
# 关键安全说明：
# - FakeTCP 模式必须配合 iptables 规则，否则内核会发送 RST 导致连接不稳定
# - OpenWrt 环境下必须启用 --keep-rule，防止规则被系统清除
# - 必须启用 --wait-lock，防止 iptables 锁冲突

START=90
STOP=10

USE_PROCD=1
PROG=/usr/bin/udp2raw
NAME=udp2raw

# 全局配置变量
GLOBAL_ENABLED=0
GLOBAL_KEEP_RULE=1
GLOBAL_RETRY_ON_ERROR=1
GLOBAL_LOG_LEVEL=4
GLOBAL_WAIT_LOCK=1

# 日志函数
log_info() {
    logger -t "$NAME" -p daemon.info "$1"
}

log_warn() {
    logger -t "$NAME" -p daemon.warn "$1"
}

log_error() {
    logger -t "$NAME" -p daemon.err "$1"
}

# 检查依赖环境
validate_environment() {
    # 检查可执行文件
    if [ ! -x "$PROG" ]; then
        log_error "udp2raw binary not found at $PROG or not executable"
        return 1
    fi
    
    # 检查 iptables（FakeTCP 模式必需）
    if ! command -v iptables >/dev/null 2>&1; then
        log_warn "iptables not found - FakeTCP mode may not work correctly"
    fi
    
    # 检查 ip6tables（IPv6 支持）
    if ! command -v ip6tables >/dev/null 2>&1; then
        log_warn "ip6tables not found - IPv6 support disabled"
    fi
    
    return 0
}

# 解析全局配置
parse_general_config() {
    local section="$1"
    
    config_get_bool GLOBAL_ENABLED "$section" enabled 0
    config_get_bool GLOBAL_KEEP_RULE "$section" keep_rule 1
    config_get_bool GLOBAL_RETRY_ON_ERROR "$section" retry_on_error 1
    config_get GLOBAL_LOG_LEVEL "$section" log_level "4"
    config_get_bool GLOBAL_WAIT_LOCK "$section" wait_lock 1
}

# 启动单个隧道实例
start_tunnel() {
    local section="$1"
    local disabled mode alias
    local local_addr local_port remote_addr remote_port
    local key raw_mode cipher_mode auth_mode
    local auto_rule source_ip source_port seq_mode
    local lower_level disable_anti_replay fix_gro
    local mtu_warn sock_buf force_sock_buf dev
    local extra_args
    
    # 检查是否禁用
    config_get_bool disabled "$section" disabled 0
    if [ "$disabled" = "1" ]; then
        return 0
    fi
    
    # 获取基本配置
    config_get mode "$section" mode
    config_get alias "$section" alias "$section"
    
    if [ -z "$mode" ]; then
        log_error "[$alias] Mode not specified (must be 'client' or 'server'), skipping"
        return 1
    fi
    
    # 获取地址配置
    config_get local_addr "$section" local_addr "0.0.0.0"
    config_get local_port "$section" local_port
    config_get remote_addr "$section" remote_addr
    config_get remote_port "$section" remote_port
    
    # 验证必需参数
    if [ -z "$local_port" ]; then
        log_error "[$alias] Local port is required, skipping"
        return 1
    fi
    
    if [ -z "$remote_addr" ] || [ -z "$remote_port" ]; then
        log_error "[$alias] Remote address and port are required, skipping"
        return 1
    fi
    
    # 获取密钥（必需）
    config_get key "$section" key
    if [ -z "$key" ]; then
        log_error "[$alias] Password/key is required, skipping"
        return 1
    fi
    
    # 警告弱密码
    case "$key" in
        password|passwd|123456|"secret key")
            log_warn "[$alias] WARNING: Using weak password! Please change to a strong random password."
            ;;
    esac
    
    # 获取协议配置
    config_get raw_mode "$section" raw_mode "faketcp"
    config_get cipher_mode "$section" cipher_mode "aes128cbc"
    config_get auth_mode "$section" auth_mode "hmac_sha1"
    
    # 获取规则管理配置
    config_get_bool auto_rule "$section" auto_rule 1
    
    # 获取高级选项
    config_get source_ip "$section" source_ip
    config_get source_port "$section" source_port
    config_get seq_mode "$section" seq_mode "3"
    config_get lower_level "$section" lower_level
    config_get_bool disable_anti_replay "$section" disable_anti_replay 0
    config_get_bool fix_gro "$section" fix_gro 0
    config_get mtu_warn "$section" mtu_warn
    config_get sock_buf "$section" sock_buf
    config_get_bool force_sock_buf "$section" force_sock_buf 0
    config_get dev "$section" dev
    config_get extra_args "$section" extra_args
    
    # ==================== 构建命令行参数 ====================
    local args=""
    
    # 模式参数
    case "$mode" in
        client)
            args="-c"
            ;;
        server)
            args="-s"
            ;;
        *)
            log_error "[$alias] Invalid mode '$mode' (must be 'client' or 'server')"
            return 1
            ;;
    esac
    
    # 地址和端口
    args="$args -l ${local_addr}:${local_port}"
    args="$args -r ${remote_addr}:${remote_port}"
    
    # 密钥
    args="$args -k '$key'"
    
    # 协议参数
    args="$args --raw-mode $raw_mode"
    args="$args --cipher-mode $cipher_mode"
    args="$args --auth-mode $auth_mode"
    
    # ==================== 关键安全参数（OpenWrt 必需）====================
    
    # -a: 自动添加 iptables 规则（FakeTCP 模式必需！）
    if [ "$auto_rule" = "1" ]; then
        args="$args -a"
    else
        if [ "$raw_mode" = "faketcp" ] || [ "$raw_mode" = "easy-faketcp" ]; then
            log_warn "[$alias] WARNING: auto_rule disabled but using FakeTCP mode - this may cause instability!"
        fi
    fi
    
    # --keep-rule: 监控并自动恢复 iptables 规则（OpenWrt 环境强烈推荐！）
    if [ "$GLOBAL_KEEP_RULE" = "1" ]; then
        args="$args --keep-rule"
    fi
    
    # --wait-lock: 等待 iptables 锁（防止并发冲突）
    if [ "$GLOBAL_WAIT_LOCK" = "1" ]; then
        args="$args --wait-lock"
    fi
    
    # --retry-on-error: 允许在网络未完全初始化时启动
    if [ "$GLOBAL_RETRY_ON_ERROR" = "1" ]; then
        args="$args --retry-on-error"
    fi
    
    # --disable-color: 禁用日志颜色（防止日志乱码）
    args="$args --disable-color"
    
    # --log-level: 日志级别
    args="$args --log-level $GLOBAL_LOG_LEVEL"
    
    # ==================== 可选参数 ====================
    
    # 客户端专用选项
    if [ "$mode" = "client" ]; then
        [ -n "$source_ip" ] && args="$args --source-ip $source_ip"
        [ -n "$source_port" ] && args="$args --source-port $source_port"
    fi
    
    # FakeTCP 序列号模式
    if [ "$raw_mode" = "faketcp" ] || [ "$raw_mode" = "easy-faketcp" ]; then
        [ -n "$seq_mode" ] && args="$args --seq-mode $seq_mode"
    fi
    
    # OSI 第二层模式（绕过本地 iptables）
    [ -n "$lower_level" ] && args="$args --lower-level '$lower_level'"
    
    # 禁用防重放（不推荐）
    if [ "$disable_anti_replay" = "1" ]; then
        args="$args --disable-anti-replay"
        log_warn "[$alias] WARNING: Anti-replay protection disabled - not recommended!"
    fi
    
    # 修复 GRO 问题
    [ "$fix_gro" = "1" ] && args="$args --fix-gro"
    
    # MTU 警告阈值
    [ -n "$mtu_warn" ] && args="$args --mtu-warn $mtu_warn"
    
    # Socket 缓冲区大小
    [ -n "$sock_buf" ] && args="$args --sock-buf $sock_buf"
    [ "$force_sock_buf" = "1" ] && args="$args --force-sock-buf"
    
    # 绑定网络设备
    [ -n "$dev" ] && args="$args --dev $dev"
    
    # 额外参数（用户自定义）
    [ -n "$extra_args" ] && args="$args $extra_args"
    
    # ==================== 启动进程 ====================
    log_info "Starting tunnel '$alias' in $mode mode: ${local_addr}:${local_port} <-> ${remote_addr}:${remote_port}"
    
    procd_open_instance "$section"
    procd_set_param command /bin/sh -c "exec $PROG $args"
    procd_set_param respawn "${respawn_threshold:-3600}" "${respawn_timeout:-5}" "${respawn_retry:-0}"
    procd_set_param stdout 1
    procd_set_param stderr 1
    procd_set_param pidfile "/var/run/udp2raw-${section}.pid"
    procd_set_param file "/etc/config/udp2raw"
    procd_close_instance
}

# 服务触发器
service_triggers() {
    procd_add_reload_trigger "udp2raw"
    procd_add_interface_trigger "interface.*.up" wan /etc/init.d/udp2raw reload
}

# 启动服务
start_service() {
    # 环境检查
    validate_environment || return 1
    
    # 加载配置
    config_load udp2raw
    
    # 解析全局配置
    config_foreach parse_general_config general
    
    # 检查是否启用
    if [ "$GLOBAL_ENABLED" != "1" ]; then
        log_info "Service is disabled in configuration"
        return 0
    fi
    
    log_info "Starting udp2raw service..."
    
    # 启动所有隧道
    config_foreach start_tunnel tunnel
}

# 停止服务
stop_service() {
    log_info "Stopping udp2raw service..."
    # procd 会自动停止所有实例并清理 iptables 规则（如果使用了 -a 选项）
}

# 重载服务
reload_service() {
    log_info "Reloading udp2raw configuration..."
    stop
    start
}

# 服务状态
status_service() {
    local running=0
    for pidfile in /var/run/udp2raw-*.pid; do
        [ -f "$pidfile" ] || continue
        local pid=$(cat "$pidfile" 2>/dev/null)
        if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
            echo "Instance $(basename "$pidfile" .pid | sed 's/udp2raw-//') is running (PID: $pid)"
            running=1
        fi
    done
    
    if [ "$running" = "0" ]; then
        echo "No udp2raw instances are running"
        return 1
    fi
    return 0
}