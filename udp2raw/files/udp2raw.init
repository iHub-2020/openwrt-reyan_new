#!/bin/sh /etc/rc.common
# Copyright (C) 2024 iHub-2020
#
# udp2raw init script for OpenWrt
# Includes OpenWrt-specific safety defaults:
#   -a            : Auto-add iptables rules
#   --keep-rule   : Monitor and re-add rules if cleared
#   --wait-lock   : Wait for xtables lock
#   --retry-on-error : Allow starting before network init
#   --disable-color  : Clean log output

START=90
STOP=10
USE_PROCD=1

PROG=/usr/bin/udp2raw
CONFIG_FILE=/etc/config/udp2raw

# Validate required parameters
validate_tunnel_section() {
	local section="$1"
	local enabled mode server_addr server_port local_addr local_port key
	
	config_get enabled "$section" enabled 0
	[ "$enabled" = "1" ] || return 1
	
	config_get mode "$section" mode
	config_get server_addr "$section" server_addr
	config_get server_port "$section" server_port
	config_get local_addr "$section" local_addr
	config_get local_port "$section" local_port
	config_get key "$section" key
	
	# Validate required fields
	if [ -z "$mode" ]; then
		logger -t udp2raw -p daemon.err "[$section] Missing 'mode' (client/server)"
		return 1
	fi
	
	if [ -z "$server_addr" ] || [ -z "$server_port" ]; then
		logger -t udp2raw -p daemon.err "[$section] Missing server_addr or server_port"
		return 1
	fi
	
	if [ -z "$local_addr" ] || [ -z "$local_port" ]; then
		logger -t udp2raw -p daemon.err "[$section] Missing local_addr or local_port"
		return 1
	fi
	
	if [ -z "$key" ]; then
		logger -t udp2raw -p daemon.warn "[$section] No encryption key set, using default (insecure!)"
	fi
	
	return 0
}

# Start a single tunnel instance
start_tunnel() {
	local section="$1"
	local enabled mode server_addr server_port local_addr local_port
	local key raw_mode cipher_mode auth_mode
	local seq_mode fix_gro lower_level mtu_warn sock_buf force_sock_buf
	
	config_get enabled "$section" enabled 0
	[ "$enabled" = "1" ] || return 0
	
	# Validate before starting
	validate_tunnel_section "$section" || return 1
	
	# Get basic parameters
	config_get mode "$section" mode "client"
	config_get server_addr "$section" server_addr
	config_get server_port "$section" server_port
	config_get local_addr "$section" local_addr
	config_get local_port "$section" local_port
	
	# Get encryption parameters (must match on both sides)
	config_get key "$section" key "secret key"
	config_get raw_mode "$section" raw_mode "faketcp"
	config_get cipher_mode "$section" cipher_mode "aes128cbc"
	config_get auth_mode "$section" auth_mode "md5"
	
	# Get optional parameters
	config_get seq_mode "$section" seq_mode
	config_get fix_gro "$section" fix_gro 0
	config_get lower_level "$section" lower_level
	config_get mtu_warn "$section" mtu_warn
	config_get sock_buf "$section" sock_buf
	config_get force_sock_buf "$section" force_sock_buf 0
	
	# Build command line
	procd_open_instance "$section"
	procd_set_param command "$PROG"
	
	# Mode: client (-c) or server (-s)
	if [ "$mode" = "server" ]; then
		procd_append_param command -s
		procd_append_param command -l "${server_addr}:${server_port}"
		procd_append_param command -r "${local_addr}:${local_port}"
	else
		procd_append_param command -c
		procd_append_param command -l "${local_addr}:${local_port}"
		procd_append_param command -r "${server_addr}:${server_port}"
	fi
	
	# Encryption parameters
	procd_append_param command -k "$key"
	procd_append_param command --raw-mode "$raw_mode"
	procd_append_param command --cipher-mode "$cipher_mode"
	procd_append_param command --auth-mode "$auth_mode"
	
	# ========================================
	# OpenWrt Safety Defaults (CRITICAL!)
	# ========================================
	# -a: Auto-add iptables rules (prevents kernel RST)
	procd_append_param command -a
	
	# --keep-rule: Monitor and re-add rules if cleared by firewall reload
	procd_append_param command --keep-rule
	
	# --wait-lock: Wait for xtables lock to prevent conflicts
	procd_append_param command --wait-lock
	
	# --retry-on-error: Allow starting before network is fully initialized
	procd_append_param command --retry-on-error
	
	# --disable-color: Prevent ANSI codes in syslog
	procd_append_param command --disable-color
	
	# ========================================
	# Optional parameters
	# ========================================
	[ -n "$seq_mode" ] && procd_append_param command --seq-mode "$seq_mode"
	[ "$fix_gro" = "1" ] && procd_append_param command --fix-gro
	[ -n "$lower_level" ] && procd_append_param command --lower-level "$lower_level"
	[ -n "$mtu_warn" ] && procd_append_param command --mtu-warn "$mtu_warn"
	[ -n "$sock_buf" ] && procd_append_param command --sock-buf "$sock_buf"
	[ "$force_sock_buf" = "1" ] && procd_append_param command --force-sock-buf
	
	# Procd settings
	procd_set_param respawn ${respawn_threshold:-3600} ${respawn_timeout:-5} ${respawn_retry:-5}
	procd_set_param stderr 1
	procd_set_param stdout 1
	procd_set_param pidfile "/var/run/udp2raw_${section}.pid"
	
	procd_close_instance
	
	logger -t udp2raw -p daemon.info "Started tunnel [$section] in $mode mode"
}

start_service() {
	local enabled
	
	# Check if binary exists
	if [ ! -x "$PROG" ]; then
		logger -t udp2raw -p daemon.err "Binary not found: $PROG"
		return 1
	fi
	
	# Check global enable switch
	config_load udp2raw
	config_get enabled globals enabled 0
	
	if [ "$enabled" != "1" ]; then
		logger -t udp2raw -p daemon.info "Service disabled globally"
		return 0
	fi
	
	# Start all enabled tunnel instances
	config_foreach start_tunnel tunnel
}

stop_service() {
	logger -t udp2raw -p daemon.info "Stopping all udp2raw instances"
	# Note: iptables rules are auto-cleaned by udp2raw when using -a
}

service_triggers() {
	procd_add_reload_trigger "udp2raw"
}

reload_service() {
	stop
	start
}

# Status check function
status() {
	local running=0
	
	if pgrep -x udp2raw >/dev/null 2>&1; then
		echo "udp2raw is running"
		pgrep -a -x udp2raw
		running=1
	else
		echo "udp2raw is not running"
	fi
	
	echo ""
	echo "iptables rules (udp2raw related):"
	iptables -L -n 2>/dev/null | grep -i "udp2raw\|DROP.*tcp.*dpt:" || echo "  (none found)"
	
	return $((1 - running))
}