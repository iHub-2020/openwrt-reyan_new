#!/bin/sh /etc/rc.common
# Copyright (C) 2024 iHub-2020
#
# udp2raw init script for OpenWrt
# Includes OpenWrt-specific safety defaults:
#   -a            : Auto-add iptables rules
#   --keep-rule   : Monitor and re-add rules if cleared
#   --wait-lock   : Wait for xtables lock
#   --retry-on-error : Allow starting before network init
#   --disable-color  : Clean log output
#
# Version: 1.1.1
# Last Updated: 2026-01-10
#
# Changelog:
#   v1.1.1 - Fixed syntax error in start_tunnel
#          - Added support for typed sections (config client/server)
#   v1.1.0 - Fixed UCI field names to match LuCI (remote_addr/remote_port)
#          - Changed global section from 'globals' to 'general'
#          - Added support for all LuCI configurable options
#          - Added source_ip/source_port for client mode
#   v1.0.0 - Initial release

START=90
STOP=10
USE_PROCD=1

PROG=/usr/bin/udp2raw
CONFIG_FILE=/etc/config/udp2raw

# Validate required parameters
validate_tunnel_section() {
	local section="$1"
	local default_mode="$2"
	local disabled mode remote_addr remote_port local_addr local_port key
	
	config_get disabled "$section" disabled 0
	[ "$disabled" = "1" ] && return 1
	
	config_get mode "$section" mode "$default_mode"
	config_get remote_addr "$section" remote_addr
	config_get remote_port "$section" remote_port
	config_get local_addr "$section" local_addr
	config_get local_port "$section" local_port
	config_get key "$section" key
	
	# Validate required fields
	if [ -z "$mode" ]; then
		logger -t udp2raw -p daemon.err "[$section] Missing 'mode' (client/server)"
		return 1
	fi
	
	if [ -z "$remote_addr" ] || [ -z "$remote_port" ]; then
		logger -t udp2raw -p daemon.err "[$section] Missing remote_addr or remote_port"
		return 1
	fi
	
	if [ -z "$local_addr" ] || [ -z "$local_port" ]; then
		logger -t udp2raw -p daemon.err "[$section] Missing local_addr or local_port"
		return 1
	fi
	
	if [ -z "$key" ]; then
		logger -t udp2raw -p daemon.warn "[$section] No encryption key set, using default (insecure!)"
	fi
	
	return 0
}

# Start a single tunnel instance
start_tunnel() {
	local section="$1"
	local default_mode="$2"
	local disabled mode remote_addr remote_port local_addr local_port
	local key raw_mode cipher_mode auth_mode auto_rule keep_rule
	local seq_mode fix_gro lower_level mtu_warn sock_buf force_sock_buf
	local source_ip source_port disable_anti_replay disable_bpf dev hb_len
	local log_level
	
	config_get disabled "$section" disabled 0
	[ "$disabled" = "1" ] && {
		logger -t udp2raw -p daemon.info "[$section] Tunnel disabled, skipping"
		return 0
	}
	
	# Validate before starting
	validate_tunnel_section "$section" "$default_mode" || return 1
	
	# Get basic parameters
	config_get mode "$section" mode "$default_mode"
	# Fallback if mode is still empty
	[ -z "$mode" ] && mode="client"

	config_get remote_addr "$section" remote_addr
	config_get remote_port "$section" remote_port
	config_get local_addr "$section" local_addr
	config_get local_port "$section" local_port
	
	# Get encryption parameters (must match on both sides)
	config_get key "$section" key "secret key"
	config_get raw_mode "$section" raw_mode "faketcp"
	config_get cipher_mode "$section" cipher_mode "aes128cbc"
	config_get auth_mode "$section" auth_mode "hmac_sha1"
	
	# Get iptables options
	config_get auto_rule "$section" auto_rule 1
	config_get keep_rule "$section" keep_rule 0
	
	# Get optional parameters
	config_get seq_mode "$section" seq_mode
	config_get fix_gro "$section" fix_gro 0
	config_get lower_level "$section" lower_level
	config_get mtu_warn "$section" mtu_warn
	config_get sock_buf "$section" sock_buf
	config_get force_sock_buf "$section" force_sock_buf 0
	config_get disable_anti_replay "$section" disable_anti_replay 0
	config_get disable_bpf "$section" disable_bpf 0
	config_get dev "$section" dev
	config_get hb_len "$section" hb_len
	
	# Client-only options
	config_get source_ip "$section" source_ip
	config_get source_port "$section" source_port
	
	# Get log level from global settings
	config_get log_level general log_level 4
	
	# Build command line
	procd_open_instance "$section"
	procd_set_param command "$PROG"
	
	# Mode: client (-c) or server (-s)
	if [ "$mode" = "server" ]; then
		procd_append_param command -s
		# Server: -l is listen address (external), -r is forward target (internal)
		procd_append_param command -l "${local_addr}:${local_port}"
		procd_append_param command -r "${remote_addr}:${remote_port}"
	else
		procd_append_param command -c
		# Client: -l is local listen (for apps), -r is remote server
		procd_append_param command -l "${local_addr}:${local_port}"
		procd_append_param command -r "${remote_addr}:${remote_port}"
	fi
	
	# Encryption parameters
	procd_append_param command -k "$key"
	procd_append_param command --raw-mode "$raw_mode"
	procd_append_param command --cipher-mode "$cipher_mode"
	procd_append_param command --auth-mode "$auth_mode"
	
	# Log level
	procd_append_param command --log-level "$log_level"
	
	# ========================================
	# Iptables options
	# ========================================
	[ "$auto_rule" = "1" ] && procd_append_param command -a
	[ "$keep_rule" = "1" ] && procd_append_param command --keep-rule
	
	# ========================================
	# OpenWrt Safety Defaults (CRITICAL!)
	# ========================================
	# --wait-lock: Wait for xtables lock to prevent conflicts
	procd_append_param command --wait-lock
	
	# --retry-on-error: Allow starting before network is fully initialized
	procd_append_param command --retry-on-error
	
	# --disable-color: Prevent ANSI codes in syslog
	procd_append_param command --disable-color
	
	# ========================================
	# Optional parameters
	# ========================================
	[ -n "$seq_mode" ] && procd_append_param command --seq-mode "$seq_mode"
	[ "$fix_gro" = "1" ] && procd_append_param command --fix-gro
	[ -n "$lower_level" ] && procd_append_param command --lower-level "$lower_level"
	[ -n "$mtu_warn" ] && procd_append_param command --mtu-warn "$mtu_warn"
	[ -n "$sock_buf" ] && procd_append_param command --sock-buf "$sock_buf"
	[ "$force_sock_buf" = "1" ] && procd_append_param command --force-sock-buf
	[ "$disable_anti_replay" = "1" ] && procd_append_param command --disable-anti-replay
	[ "$disable_bpf" = "1" ] && procd_append_param command --disable-bpf
	[ -n "$dev" ] && procd_append_param command --dev "$dev"
	[ -n "$hb_len" ] && procd_append_param command --hb-len "$hb_len"
	
	# Client-only options
	if [ "$mode" = "client" ]; then
		[ -n "$source_ip" ] && procd_append_param command --source-ip "$source_ip"
		[ -n "$source_port" ] && procd_append_param command --source-port "$source_port"
	fi
	
	# Extra arguments (from config)
	local extra_args
	config_get extra_args "$section" extra_args
	if [ -n "$extra_args" ]; then
		local arg
		for arg in $extra_args; do
			procd_append_param command "$arg"
		done
	fi
	
	# Procd settings
	procd_set_param respawn ${respawn_threshold:-3600} ${respawn_timeout:-5} ${respawn_retry:-5}
	procd_set_param stderr 1
	procd_set_param stdout 1
	procd_set_param pidfile "/var/run/udp2raw_${section}.pid"
	
	procd_close_instance
	
	logger -t udp2raw -p daemon.info "Started tunnel [$section] in $mode mode"
}

start_service() {
	local enabled
	
	# Check if binary exists
	if [ ! -x "$PROG" ]; then
		logger -t udp2raw -p daemon.err "Binary not found: $PROG"
		return 1
	fi
	
	# Check global enable switch
	config_load udp2raw
	config_get enabled general enabled 0
	
	if [ "$enabled" != "1" ]; then
		logger -t udp2raw -p daemon.info "Service disabled globally"
		return 0
	fi
	
	# Check active tunnels filter
	local active_tunnels
	config_get active_tunnels general active_tunnels
	
	# Start tunnel instances
	if [ -n "$active_tunnels" ]; then
		# Only start selected tunnels (legacy support)
		local tunnel
		for tunnel in $active_tunnels; do
			start_tunnel "$tunnel"
		done
	else
		# Start all enabled instances of various types
		# 1. 'client' typed sections (default mode=client)
		config_foreach start_tunnel client "client"
		# 2. 'server' typed sections (default mode=server)
		config_foreach start_tunnel server "server"
		# 3. 'tunnel' typed sections (legacy, mode must be specified in option)
		config_foreach start_tunnel tunnel
	fi
}

stop_service() {
	logger -t udp2raw -p daemon.info "Stopping all udp2raw instances"
	# Note: iptables rules are auto-cleaned by udp2raw when using -a
}

service_triggers() {
	procd_add_reload_trigger "udp2raw"
}

reload_service() {
	stop
	start
}

# Status check function
status() {
	local running=0
	
	if pgrep -x udp2raw >/dev/null 2>&1; then
		echo "udp2raw is running"
		pgrep -a -x udp2raw
		running=1
	else
		echo "udp2raw is not running"
	fi
	
	echo ""
	echo "iptables rules (udp2raw related):"
	iptables -L -n 2>/dev/null | grep -i "udp2raw\|DROP.*tcp.*dpt:" || echo "  (none found)"
	
	return $((1 - running))
}