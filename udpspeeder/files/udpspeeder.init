#!/bin/sh /etc/rc.common
# Copyright (C) 2024 iHub-2020
#
# udpspeeder init script for OpenWrt
# Includes OpenWrt-specific safety defaults:
#   -a            : Auto-add iptables rules
#   --keep-rule   : Monitor and re-add rules if cleared
#   --wait-lock   : Wait for xtables lock
#   --retry-on-error : Allow starting before network init
#   --disable-color  : Clean log output
#
# Version: 2.0.0
# Last Updated: 2026-01-16
#
# Changelog:
#   v2.0.0 - FIX: Aligned with official udpspeeder documentation
#          - Changed auth_mode default from hmac_sha1 to md5 (official default)
#          - cipher_mode remains aes128cbc (official default, already correct)
#   v1.1.5 - Removed debug logging, finalized for production.
#   v1.1.4 - Debug version (internal).
#   v1.1.3 - Fixed "Service Stopped" issue:
#          - Removed 'enabled' check from validation function.
#          - Switched to string comparison for 'enabled' check.
#          - Added defaults for local_addr in validation.

START=90
STOP=10
USE_PROCD=1

PROG=/usr/bin/udpspeeder
CONFIG_FILE=/etc/config/udpspeeder

# Validate required parameters
validate_tunnel_section() {
	local section="$1"
	local default_mode="$2"
	local mode remote_addr remote_port local_addr local_port key
	
	config_get mode "$section" mode "$default_mode"
	config_get remote_addr "$section" remote_addr
	config_get remote_port "$section" remote_port
	config_get local_addr "$section" local_addr
	config_get local_port "$section" local_port
	config_get key "$section" key
	
	# Apply defaults for validation if missing
	if [ -z "$local_addr" ]; then
		[ "$mode" = "server" ] && local_addr="0.0.0.0"
		[ "$mode" = "client" ] && local_addr="127.0.0.1"
	fi
	
	# Validate required fields
	if [ -z "$mode" ]; then
		logger -t udpspeeder -p daemon.err "[$section] Missing 'mode' (client/server)"
		return 1
	fi
	
	if [ -z "$remote_addr" ] || [ -z "$remote_port" ]; then
		logger -t udpspeeder -p daemon.err "[$section] Missing remote_addr or remote_port"
		return 1
	fi
	
	if [ -z "$local_addr" ] || [ -z "$local_port" ]; then
		logger -t udpspeeder -p daemon.err "[$section] Missing local_addr or local_port"
		return 1
	fi
	
	if [ -z "$key" ]; then
		logger -t udpspeeder -p daemon.warn "[$section] No encryption key set, using default (insecure!)"
	fi
	
	return 0
}

# Start a single tunnel instance
start_tunnel() {
	local section="$1"
	local default_mode="$2"
	local enabled mode remote_addr remote_port local_addr local_port
	local key raw_mode cipher_mode auth_mode auto_rule keep_rule
	local seq_mode fix_gro lower_level mtu_warn sock_buf force_sock_buf
	local source_ip source_port disable_anti_replay disable_bpf dev hb_len
	local log_level
	
	# Check enabled status (String comparison for robustness)
	config_get enabled "$section" enabled '0'
	
	if [ "$enabled" != "1" ]; then
		return 0
	fi
	
	# Validate before starting
	validate_tunnel_section "$section" "$default_mode" || {
		logger -t udpspeeder -p daemon.err "[$section] Validation failed, skipping."
		return 1
	}
	
	# Get basic parameters
	config_get mode "$section" mode "$default_mode"
	[ -z "$mode" ] && mode="client"

	config_get remote_addr "$section" remote_addr
	config_get remote_port "$section" remote_port
	config_get local_addr "$section" local_addr
	config_get local_port "$section" local_port
	
	# Apply defaults for execution
	if [ -z "$local_addr" ]; then
		[ "$mode" = "server" ] && local_addr="0.0.0.0"
		[ "$mode" = "client" ] && local_addr="127.0.0.1"
	fi
	
	# Get encryption parameters (Official defaults)
	config_get key "$section" key "secret key"
	config_get raw_mode "$section" raw_mode "faketcp"
	config_get cipher_mode "$section" cipher_mode "aes128cbc"
	config_get auth_mode "$section" auth_mode "md5"
	
	# Get iptables options
	config_get auto_rule "$section" auto_rule 1
	config_get keep_rule "$section" keep_rule 0
	
	# Get optional parameters
	config_get seq_mode "$section" seq_mode
	config_get fix_gro "$section" fix_gro 0
	config_get lower_level "$section" lower_level
	config_get mtu_warn "$section" mtu_warn
	config_get sock_buf "$section" sock_buf
	config_get force_sock_buf "$section" force_sock_buf 0
	config_get disable_anti_replay "$section" disable_anti_replay 0
	config_get disable_bpf "$section" disable_bpf 0
	config_get dev "$section" dev
	config_get hb_len "$section" hb_len
	
	# Client-only options
	config_get source_ip "$section" source_ip
	config_get source_port "$section" source_port
	
	# Get log level from global settings
	config_get log_level general log_level 4
	
	# Build command line
	procd_open_instance "$section"
	procd_set_param command "$PROG"
	
	if [ "$mode" = "server" ]; then
		procd_append_param command -s
		procd_append_param command -l "${local_addr}:${local_port}"
		procd_append_param command -r "${remote_addr}:${remote_port}"
	else
		procd_append_param command -c
		procd_append_param command -l "${local_addr}:${local_port}"
		procd_append_param command -r "${remote_addr}:${remote_port}"
	fi
	
	procd_append_param command -k "$key"
	procd_append_param command --raw-mode "$raw_mode"
	procd_append_param command --cipher-mode "$cipher_mode"
	procd_append_param command --auth-mode "$auth_mode"
	procd_append_param command --log-level "$log_level"
	
	# Iptables options
	[ "$auto_rule" = "1" ] && procd_append_param command -a
	[ "$keep_rule" = "1" ] && procd_append_param command --keep-rule
	
	# Safety Defaults
	procd_append_param command --wait-lock
	procd_append_param command --retry-on-error
	procd_append_param command --disable-color
	
	# Optional parameters
	[ -n "$seq_mode" ] && procd_append_param command --seq-mode "$seq_mode"
	[ "$fix_gro" = "1" ] && procd_append_param command --fix-gro
	[ -n "$lower_level" ] && procd_append_param command --lower-level "$lower_level"
	[ -n "$mtu_warn" ] && procd_append_param command --mtu-warn "$mtu_warn"
	[ -n "$sock_buf" ] && procd_append_param command --sock-buf "$sock_buf"
	[ "$force_sock_buf" = "1" ] && procd_append_param command --force-sock-buf
	[ "$disable_anti_replay" = "1" ] && procd_append_param command --disable-anti-replay
	[ "$disable_bpf" = "1" ] && procd_append_param command --disable-bpf
	[ -n "$dev" ] && procd_append_param command --dev "$dev"
	[ -n "$hb_len" ] && procd_append_param command --hb-len "$hb_len"
	
	if [ "$mode" = "client" ]; then
		[ -n "$source_ip" ] && procd_append_param command --source-ip "$source_ip"
		[ -n "$source_port" ] && procd_append_param command --source-port "$source_port"
	fi
	
	local extra_args
	config_get extra_args "$section" extra_args
	if [ -n "$extra_args" ]; then
		local arg
		for arg in $extra_args; do
			procd_append_param command "$arg"
		done
	fi
	
	procd_set_param respawn ${respawn_threshold:-3600} ${respawn_timeout:-5} ${respawn_retry:-5}
	procd_set_param stderr 1
	procd_set_param stdout 1
	procd_set_param pidfile "/var/run/udpspeeder_${section}.pid"
	
	procd_close_instance
	
	logger -t udpspeeder -p daemon.info "Started tunnel [$section] in $mode mode"
}

start_service() {
	local enabled
	
	if [ ! -x "$PROG" ]; then
		logger -t udpspeeder -p daemon.err "Binary not found: $PROG"
		return 1
	fi
	
	config_load udpspeeder
	config_get enabled general enabled '0'
	
	if [ "$enabled" != "1" ]; then
		logger -t udpspeeder -p daemon.info "Service disabled globally"
		return 0
	fi
	
	local active_tunnels
	config_get active_tunnels general active_tunnels
	
	if [ -n "$active_tunnels" ]; then
		local tunnel
		for tunnel in $active_tunnels; do
			start_tunnel "$tunnel"
		done
	else
		config_foreach start_tunnel client "client"
		config_foreach start_tunnel server "server"
		config_foreach start_tunnel tunnel
	fi
}

stop_service() {
	logger -t udpspeeder -p daemon.info "Stopping all udpspeeder instances"
}

service_triggers() {
	procd_add_reload_trigger "udpspeeder"
}

reload_service() {
	stop
	start
}

status() {
	local running=0
	
	if pgrep -x udpspeeder >/dev/null 2>&1; then
		echo "udpspeeder is running"
		pgrep -a -x udpspeeder
		running=1
	else
		echo "udpspeeder is not running"
	fi
	
	echo ""
	echo "iptables rules (udpspeeder related):"
	iptables -L -n 2>/dev/null | grep -i "udpspeeder\|DROP.*tcp.*dpt:" || echo "  (none found)"
	
	return $((1 - running))
}
