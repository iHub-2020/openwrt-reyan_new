# ==============================================================================
# Workflow: Build UDP-Tunnel IPKs
# Description: Automated build pipeline for udp2raw and luci-app-udp-tunnel packages
#              using OpenWrt SDK for x86_64 and aarch64 architectures.
#
# Author: Reyanmatic
# Date: 2026-01-14
# Version: 2.2.0
# License: MIT
#
# Changelog:
#   v2.2.0 - Use Python po2lmo script to avoid C compilation dependency hell
#          - lmo.c requires plural_formula.h (generated by lemon parser)
#          - Python implementation is self-contained and reliable
#   v2.1.0 - Attempted fix: include lib/lmo.c (still missing plural_formula.h)
#   v2.0.0 - Fixed translation by pre-compiling LMO in workflow before SDK build
#   v1.9.0 - Added po2lmo tool compilation step (had issues)
#   v1.8.0 - Fixed artifact/release cleanup permissions issue
# ==============================================================================

name: build-udp-tunnel-ipks

on:
  workflow_dispatch:
    inputs:
      debug_build:
        description: 'Enable verbose build logs (V=s)'
        required: false
        default: 'true'
        type: boolean

permissions:
  contents: write
  actions: write

jobs:
  build:
    name: Build for ${{ matrix.arch }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: x86_64
            sdk_url: https://downloads.openwrt.org/releases/23.05.5/targets/x86/64/openwrt-sdk-23.05.5-x86-64_gcc-12.3.0_musl.Linux-x86_64.tar.xz
            sdk_name: openwrt-sdk-23.05.5-x86-64_gcc-12.3.0_musl.Linux-x86_64
          
          - arch: aarch64
            sdk_url: https://downloads.openwrt.org/releases/23.05.5/targets/rockchip/armv8/openwrt-sdk-23.05.5-rockchip-armv8_gcc-12.3.0_musl.Linux-x86_64.tar.xz
            sdk_name: openwrt-sdk-23.05.5-rockchip-armv8_gcc-12.3.0_musl.Linux-x86_64

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Install Build Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential libncurses5-dev gawk git gettext libssl-dev xsltproc wget unzip python3 file zstd
          git config --global --add safe.directory '*'

      - name: Download and Extract OpenWrt SDK
        run: |
          wget -q -O sdk.tar.xz ${{ matrix.sdk_url }}
          tar -xf sdk.tar.xz
          mv ${{ matrix.sdk_name }} sdk

      - name: Update and Install Feeds
        working-directory: sdk
        run: |
          cat > feeds.conf << 'EOF'
          src-git-full base https://github.com/openwrt/openwrt.git;openwrt-23.05
          src-git packages https://github.com/openwrt/packages.git;openwrt-23.05
          src-git luci https://github.com/openwrt/luci.git;openwrt-23.05
          src-git routing https://github.com/openwrt/routing.git;openwrt-23.05
          EOF
          
          for i in 1 2 3; do
            ./scripts/feeds update -a && break
            echo "Retry $i..."
            sleep 10
          done
          
          [ -d "feeds/base" ] || { echo "feeds/base missing"; exit 1; }
          ./scripts/feeds install luci-base luci-compat iptables

      # ============================================================
      # 使用 Python 脚本预编译翻译文件
      # 完全避开 C 编译的依赖地狱 (lmo.c -> plural_formula.h -> lemon)
      # ============================================================
      - name: Pre-compile Translations with Python
        run: |
          echo "=========================================="
          echo "Creating Python po2lmo tool"
          echo "=========================================="
          
          cat > /tmp/po2lmo.py << 'PYTHON_SCRIPT'
          #!/usr/bin/env python3
          """
          po2lmo.py - Convert PO files to LMO format for LuCI
          Compatible with OpenWrt LuCI translation system
          
          This is a pure Python implementation that avoids the C compilation
          dependency chain (po2lmo.c -> lmo.c -> plural_formula.h -> lemon)
          """
          
          import struct
          import sys
          
          def sfh_hash(data):
              """
              SuperFastHash implementation
              http://www.azillionmonkeys.com/qed/hash.html
              """
              if isinstance(data, str):
                  data = data.encode('utf-8')
              
              length = len(data)
              if length == 0:
                  return 0
              
              h = length & 0xFFFFFFFF
              rem = length & 3
              num = length >> 2
              
              i = 0
              while num > 0:
                  h = (h + (data[i] | (data[i+1] << 8))) & 0xFFFFFFFF
                  tmp = ((data[i+2] | (data[i+3] << 8)) << 11) ^ h
                  h = ((h << 16) ^ tmp) & 0xFFFFFFFF
                  h = (h + (h >> 11)) & 0xFFFFFFFF
                  i += 4
                  num -= 1
              
              if rem == 3:
                  h = (h + (data[i] | (data[i+1] << 8))) & 0xFFFFFFFF
                  h = (h ^ (h << 16)) & 0xFFFFFFFF
                  h = (h ^ (data[i+2] << 18)) & 0xFFFFFFFF
                  h = (h + (h >> 11)) & 0xFFFFFFFF
              elif rem == 2:
                  h = (h + (data[i] | (data[i+1] << 8))) & 0xFFFFFFFF
                  h = (h ^ (h << 11)) & 0xFFFFFFFF
                  h = (h + (h >> 17)) & 0xFFFFFFFF
              elif rem == 1:
                  h = (h + data[i]) & 0xFFFFFFFF
                  h = (h ^ (h << 10)) & 0xFFFFFFFF
                  h = (h + (h >> 1)) & 0xFFFFFFFF
              
              h = (h ^ (h << 3)) & 0xFFFFFFFF
              h = (h + (h >> 5)) & 0xFFFFFFFF
              h = (h ^ (h << 4)) & 0xFFFFFFFF
              h = (h + (h >> 17)) & 0xFFFFFFFF
              h = (h ^ (h << 25)) & 0xFFFFFFFF
              h = (h + (h >> 6)) & 0xFFFFFFFF
              
              return h
          
          def unescape_string(s):
              """Unescape PO file string escapes"""
              result = []
              i = 0
              while i < len(s):
                  if s[i] == '\\' and i + 1 < len(s):
                      c = s[i + 1]
                      if c == 'n':
                          result.append('\n')
                      elif c == 't':
                          result.append('\t')
                      elif c == 'r':
                          result.append('\r')
                      elif c == '"':
                          result.append('"')
                      elif c == '\\':
                          result.append('\\')
                      else:
                          result.append(s[i])
                          result.append(c)
                      i += 2
                  else:
                      result.append(s[i])
                      i += 1
              return ''.join(result)
          
          def parse_po(filename):
              """Parse PO file and return list of (msgid, msgstr) tuples"""
              entries = []
              
              with open(filename, 'r', encoding='utf-8') as f:
                  lines = f.readlines()
              
              msgid_parts = []
              msgstr_parts = []
              current = None
              
              for line in lines:
                  line = line.rstrip('\n\r')
                  
                  if line.startswith('msgid "') and line.endswith('"'):
                      # Save previous entry
                      if msgid_parts and msgstr_parts:
                          msgid = unescape_string(''.join(msgid_parts))
                          msgstr = unescape_string(''.join(msgstr_parts))
                          if msgid and msgstr:
                              entries.append((msgid, msgstr))
                      
                      msgid_parts = [line[7:-1]]
                      msgstr_parts = []
                      current = 'msgid'
                  elif line.startswith('msgstr "') and line.endswith('"'):
                      msgstr_parts = [line[8:-1]]
                      current = 'msgstr'
                  elif line.startswith('"') and line.endswith('"'):
                      content = line[1:-1]
                      if current == 'msgid':
                          msgid_parts.append(content)
                      elif current == 'msgstr':
                          msgstr_parts.append(content)
              
              # Last entry
              if msgid_parts and msgstr_parts:
                  msgid = unescape_string(''.join(msgid_parts))
                  msgstr = unescape_string(''.join(msgstr_parts))
                  if msgid and msgstr:
                      entries.append((msgid, msgstr))
              
              return entries
          
          def write_lmo(entries, output_file):
              """
              Write LMO file
              
              LMO format (big-endian):
              - Array of lmo_entry structs (16 bytes each):
                - key_id  (uint32): hash of msgid
                - val_id  (uint32): hash of msgstr  
                - offset  (uint32): offset to string data from file start
                - length  (uint32): length of msgstr
              - String data (each string padded to 4-byte boundary)
              """
              string_data = bytearray()
              index_entries = []
              
              for msgid, msgstr in entries:
                  msgid_bytes = msgid.encode('utf-8')
                  msgstr_bytes = msgstr.encode('utf-8')
                  
                  key_id = sfh_hash(msgid_bytes)
                  val_id = sfh_hash(msgstr_bytes)
                  
                  offset = len(string_data)
                  length = len(msgstr_bytes)
                  
                  string_data.extend(msgstr_bytes)
                  # Pad to 4-byte boundary
                  padding = (4 - (length % 4)) % 4
                  string_data.extend(b'\x00' * padding)
                  
                  index_entries.append((key_id, val_id, offset, length))
              
              # Sort by key_id for binary search lookup
              index_entries.sort(key=lambda x: x[0])
              
              # Calculate header size
              header_size = len(index_entries) * 16
              
              with open(output_file, 'wb') as f:
                  # Write index entries
                  for key_id, val_id, offset, length in index_entries:
                      f.write(struct.pack('>I', key_id))
                      f.write(struct.pack('>I', val_id))
                      f.write(struct.pack('>I', header_size + offset))
                      f.write(struct.pack('>I', length))
                  
                  # Write string data
                  f.write(string_data)
          
          def main():
              if len(sys.argv) != 3:
                  print(f"Usage: {sys.argv[0]} input.po output.lmo", file=sys.stderr)
                  sys.exit(1)
              
              try:
                  entries = parse_po(sys.argv[1])
                  write_lmo(entries, sys.argv[2])
                  print(f"Successfully converted {len(entries)} translation entries")
              except Exception as e:
                  print(f"Error: {e}", file=sys.stderr)
                  sys.exit(1)
          
          if __name__ == '__main__':
              main()
          PYTHON_SCRIPT
          
          chmod +x /tmp/po2lmo.py
          
          echo "=========================================="
          echo "Compiling translation files"
          echo "=========================================="
          
          PO_FILE="luci-app-udp-tunnel/po/zh_Hans/udp-tunnel.po"
          
          if [ -f "$PO_FILE" ]; then
            echo "✓ Found PO file: $PO_FILE"
            echo "  Size: $(wc -c < "$PO_FILE") bytes"
            echo "  Lines: $(wc -l < "$PO_FILE")"
            echo ""
            
            mkdir -p luci-app-udp-tunnel/i18n
            
            echo "Converting PO -> LMO..."
            python3 /tmp/po2lmo.py "$PO_FILE" "luci-app-udp-tunnel/i18n/udp-tunnel.zh-cn.lmo"
            
            if [ -f "luci-app-udp-tunnel/i18n/udp-tunnel.zh-cn.lmo" ]; then
              LMO_SIZE=$(wc -c < "luci-app-udp-tunnel/i18n/udp-tunnel.zh-cn.lmo")
              echo ""
              echo "✓ LMO file created successfully!"
              echo "  Output: luci-app-udp-tunnel/i18n/udp-tunnel.zh-cn.lmo"
              echo "  Size: $LMO_SIZE bytes"
              ls -la luci-app-udp-tunnel/i18n/
              
              echo ""
              echo "=== LMO file hexdump (first 64 bytes) ==="
              xxd -l 64 luci-app-udp-tunnel/i18n/udp-tunnel.zh-cn.lmo || \
              od -A x -t x1z -v luci-app-udp-tunnel/i18n/udp-tunnel.zh-cn.lmo | head -5
            else
              echo "✗ LMO file was not created!"
              exit 1
            fi
          else
            echo "✗ PO file not found: $PO_FILE"
            echo ""
            echo "Available PO files:"
            find luci-app-udp-tunnel -name "*.po" 2>/dev/null || echo "  (none found)"
            exit 1
          fi
          
          echo ""
          echo "=========================================="
          echo "✓ Translation pre-compilation complete!"
          echo "=========================================="

      - name: Prepare Package Sources
        run: |
          cp -R luci-app-udp-tunnel sdk/package/
          cp -R udp2raw sdk/package/
          
          echo "=== Verifying LMO file in SDK ==="
          ls -la sdk/package/luci-app-udp-tunnel/i18n/

      - name: Configure Build
        working-directory: sdk
        run: |
          make defconfig

      - name: Compile udp2raw
        working-directory: sdk
        run: |
          make package/udp2raw/compile V=s
          
          if ! find bin/packages -name "udp2raw*.ipk" | grep -q .; then
            echo "ERROR: udp2raw ipk not found!"
            exit 1
          fi

      - name: Compile luci-app-udp-tunnel
        working-directory: sdk
        run: |
          echo "=== Pre-compiled LMO check ==="
          ls -la package/luci-app-udp-tunnel/i18n/
          
          make package/luci-app-udp-tunnel/compile V=s
          
          if ! find bin/packages -name "luci-app-udp-tunnel*.ipk" | grep -q .; then
            echo "ERROR: luci-app-udp-tunnel ipk not found!"
            exit 1
          fi
          
          echo ""
          echo "=== Verifying language pack ==="
          I18N_IPK=$(find bin/packages -name "luci-i18n-udp-tunnel-zh-cn*.ipk" | head -1)
          if [ -n "$I18N_IPK" ]; then
            echo "Found: $I18N_IPK"
            echo "Size: $(stat -c%s "$I18N_IPK") bytes"
            
            mkdir -p /tmp/ipk-check && cd /tmp/ipk-check
            
            ar x "$GITHUB_WORKSPACE/sdk/$I18N_IPK" 2>/dev/null || \
            tar xzf "$GITHUB_WORKSPACE/sdk/$I18N_IPK" 2>/dev/null || true
            
            if [ -f data.tar.gz ]; then
              tar xzf data.tar.gz
            elif [ -f data.tar.zst ]; then
              zstd -d data.tar.zst -o data.tar && tar xf data.tar
            elif [ -f data.tar ]; then
              tar xf data.tar
            fi
            
            echo ""
            echo "=== IPK contents ==="
            find . -type f -name "*.lmo" -exec ls -la {} \; -exec file {} \;
            
            LMO_COUNT=$(find . -name "*.lmo" -size +0 | wc -l)
            if [ "$LMO_COUNT" -gt 0 ]; then
              echo ""
              echo "✓✓✓ SUCCESS: Found $LMO_COUNT valid LMO file(s)! ✓✓✓"
            else
              echo ""
              echo "⚠ WARNING: No valid LMO files found in IPK"
              find . -type f
            fi
            
            cd "$GITHUB_WORKSPACE/sdk"
          else
            echo "⚠ Language pack IPK not found (might be expected if no translations)"
          fi

      - name: Organize Artifacts
        run: |
          mkdir -p artifacts
          
          find sdk/bin/packages -name "udp2raw*.ipk" -exec cp {} artifacts/ \;
          find sdk/bin/packages -name "luci-app-udp-tunnel*.ipk" -exec cp {} artifacts/ \;
          find sdk/bin/packages -name "luci-i18n-udp-tunnel*.ipk" -exec cp {} artifacts/ \;
          
          echo "=== Collected artifacts ==="
          for f in artifacts/*.ipk; do
            [ -f "$f" ] && echo "  $(basename $f): $(stat -c%s $f) bytes"
          done
          
          if [ -z "$(ls -A artifacts/ 2>/dev/null)" ]; then
            echo "ERROR: No artifacts collected!"
            exit 1
          fi

      - name: Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: udp-tunnel-${{ matrix.arch }}
          path: artifacts/*.ipk
          retention-days: 7

  release:
    name: Create Release
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Download All Artifacts
        uses: actions/download-artifact@v4
        with:
          path: release-files
          merge-multiple: true

      - name: Prepare Release Files
        run: |
          mkdir -p final-release
          find release-files -name "*.ipk" -exec cp {} final-release/ \;
          echo "=== Release files ==="
          ls -la final-release/

      - name: Generate Release Tag
        id: tag
        run: |
          TAG="v$(date +'%Y%m%d-%H%M%S')"
          echo "tag=$TAG" >> $GITHUB_OUTPUT

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.tag.outputs.tag }}
          name: UDP-Tunnel ${{ steps.tag.outputs.tag }}
          body: |
            ## UDP-Tunnel 自动构建
            
            构建时间: ${{ github.event.head_commit.timestamp || github.event.repository.updated_at }}
            
            ### 包含文件
            - udp2raw (x86_64, aarch64)
            - luci-app-udp-tunnel (x86_64, aarch64)
            - luci-i18n-udp-tunnel-zh-cn (简体中文翻译)
            
            ### 安装
            ```bash
            opkg install udp2raw*.ipk luci-app-udp-tunnel*.ipk luci-i18n-udp-tunnel*.ipk
            ```
          files: final-release/*.ipk
          draft: false
          prerelease: false

  cleanup:
    name: Cleanup Old Artifacts and Releases
    needs: release
    runs-on: ubuntu-latest
    steps:
      - name: Delete Old Artifacts
        uses: c-hive/gha-remove-artifacts@v1
        with:
          age: '1 day'
          skip-tags: false
          skip-recent: 6

      - name: Delete Old Releases
        uses: dev-drprasad/delete-older-releases@v0.3.4
        with:
          keep_latest: 3
          delete_tags: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
